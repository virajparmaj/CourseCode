break_point <- which(time_index_pw == 1985 - 1982 + 1) # Convert year to index
# Create piecewise linear term
piecewise_term <- pmax(0, time_index_pw - break_point)
# Fit piecewise linear model
fit_piecewise <- lm(hours ~ time_index_pw + piecewise_term)
# Plot data with piecewise linear trend
plot(hours, main = "Avg Hrs Worked/Week with Piecewise Linear Trend", ylab = "Avg Hrs Worked", xlab = "Time")
lines(time_index_pw, fitted(fit_piecewise), col = "blue", lwd = 2)
summary(fit_quad)
summary(fit_trend)
summary(fit_piecewise)
data(wages)
# Plot the time series
plot(wages, main="Avg Hourly Wages (1981-1987)", ylab="Wages", xlab="Time")
# Fit a linear time trend model
time_index <- 1:length(wages)
fit_linear <- lm(wages ~ time_index)
# Plot the original time series with the fitted trend line
plot(wages, main="Avg Hourly Wages (1981-1987) with Linear Trend", ylab="Wages", xlab="Time")
abline(fit_linear, col="red", lwd=2)
# Summary of the model
summary(fit_linear)
# Residuals from the linear model
residuals_linear <- residuals(fit_linear)
# Time series plot of residuals
plot(residuals_linear, main="Residuals Over Time", ylab="Residuals", xlab="Time")
# ACF of residuals
acf(residuals_linear, main="ACF of Residuals")
# Histogram of residuals
hist(residuals_linear, main="Histogram of Residuals", xlab="Residuals", breaks=10)
# Ljung-Box test for white noise in residuals
Box.test(residuals_linear, lag=10, type="Ljung-Box")
# Create a time index for the quadratic term
time_index_sq <- time_index^2
# Fit the model using least squares with both time index and its square
fit_quadratic <- lm(wages ~ time_index + I(time_index_sq))
# Display the summary of the fitted model
summary(fit_quadratic)
# Plot the original time series with the fitted quadratic trend
plot(wages, main = "Avg Hourly Wages with Quadratic Trend", ylab = "Wages", xlab = "Time")
lines(fitted(fit_quadratic), col = "red")
time_index <- time(cmort)
# Center the temperature variable
T_centered <- tempr - mean(tempr)
# Fit the linear regression model
fit_model <- lm(cmort ~ time_index + T_centered + I(T_centered^2) + part)
# Display the summary of the model
summary(fit_model)
```{r}
# Create lagged variable for P_t-4
part_lag4 <- lag(part, -4)
# Adjust variables to match lengths
cmort_adj <- cmort[5:length(cmort)]
tempr_adj <- tempr[5:length(tempr)]
part_adj <- part[5:length(part)]
part_lag4_adj <- part_lag4[5:length(part_lag4)]
# Combine data
data_combined <- data.frame(cmort_adj, tempr_adj, part_adj, part_lag4_adj)
# Scatter plot matrix
pairs(data_combined, main = "Scatter Plot Matrix")
# Pairwise correlations
correlations <- cor(data_combined, use = "complete.obs")
print(correlations)
# Prepare data
time_index <- time(cmort)
T_centered <- tempr - mean(tempr)
# Add Pt-4 (lagged) to the regression
part_lag4 <- lag(part, -4) # Lag the variable
fit_model_lag <- lm(cmort[5:length(cmort)] ~ time_index[5:length(time_index)] +
T_centered[5:length(T_centered)] + I(T_centered[5:length(T_centered)]^2) +
part[5:length(part)] + part_lag4[5:length(part_lag4)])
summary(fit_model_lag)
# Model comparison
cat("R-squared for original model:", summary(fit_model)$r.squared, "\n")
cat("R-squared for model with Pt-4:", summary(fit_model_lag)$r.squared, "\n")
knitr::opts_chunk$set(echo = TRUE)
library(astsa)
library(TSA)
# if you haven't installed the package- install the TSA package first.
#install.packages('TSA')
#do install.packages only once.- don't include this line in your Rmd file!
# jj data
data("jj")
tsplot(jj, main = "Johnson & Johnson Quarterly Earnings", ylab = "Earnings")
# Differencing
jj_diff = diff(jj)
tsplot(jj_diff, main = "Differenced Earnings")
# Log Transformation
jj_log = log(jj)
tsplot(jj_log, main = "Log Transformed Earnings")
# Seasonal Differencing (lag = 4 for quarterly data)
jj_seasonal_diff = diff(jj, lag = 4)
tsplot(jj_seasonal_diff, main = "Seasonally Differenced Earnings")
# Combination: Log then Differencing
jj_log_diff = diff(log(jj))
tsplot(jj_log_diff, main = "Log Differenced Earnings")
# Log transformation
Xt <- log(jj)
plot(Xt, main = "Log of JJ quaterly Earnings", ylab = "Log Earnings", xlab = "Time")
# xt is t.s. of log-transformed data
time_index <- time(Xt)
Q1 <- as.numeric(cycle(Xt) == 1)  # Indicator for first quarter
Q2 <- as.numeric(cycle(Xt) == 2)  # Indicator for second quarter
Q3 <- as.numeric(cycle(Xt) == 3)  # Indicator for third quarter
Q4 <- as.numeric(cycle(Xt) == 4)  # Indicator for fourth quarter
# Fit regression model
fit <- lm(Xt ~ time_index + Q1 + Q2 + Q3 + Q4)
summary(fit)
# residuals from model
residuals <- residuals(fit)
# ts of residuals
plot(residuals, main="Residuals Over Time", ylab="Residuals")
# corr in the residuals
acf(residuals, main="ACF of Residuals")
# distribution of residuals
hist(residuals, breaks=20, main="Histogram of Residuals", xlab="Residuals")
# residuals independence test
Box.test(residuals, type="Ljung-Box", lag=10)
# if you haven't installed the package- install the TSA package first.
#install.packages('TSA')
#do install.packages only once.- don't include this line in your Rmd file!
data(hours)
tsplot(hours, ylab="Avg hrs Worked", main="Avg Hrs Worked/Week (1982-1987)")
# Fit a linear model
time_index <- time(hours)
fit_trend <- lm(hours ~ time_index)
# Display the summary of the fitted model
summary(fit_trend)
# Plot the original data and add the fitted trend line
plot(hours, main="Avg Hrs Worked/Week with Linear Trend", ylab="Avg hrs Worked", xlab="Time")
abline(fit_trend, col="red", lwd=2)
# Residual Analysis
plot(residuals(fit_trend), main="Residuals Over Time", ylab="Residuals", xlab="Time") # Time series plot
acf(residuals(fit_trend), main="ACF of Residuals") # ACF plot
hist(residuals(fit_trend), main="Histogram of Residuals", xlab="Residuals", breaks=10) # Histogram
Box.test(residuals(fit_trend), lag=10, type="Ljung-Box") # Ljung-Box Test
# Time index
time_index <- 1:length(hours)
# Fit quadratic model
fit_quad <- lm(hours ~ time_index + I(time_index^2))
# Summary of fit
summary(fit_quad)
# Plot data with quadratic trend
plot(hours, main = "Avg Hrs Worked/Week with Quadratic Trend", ylab = "Avg Hrs Worked", xlab = "Time")
lines(time_index, fitted(fit_quad), col = "red", lwd = 2)
# Create time index
time_index_pw <- 1:length(hours)
# Break point at 1985
break_point <- which(time_index_pw == 1985 - 1982 + 1) # Convert year to index
# Create piecewise linear term
piecewise_term <- pmax(0, time_index_pw - break_point)
# Fit piecewise linear model
fit_piecewise <- lm(hours ~ time_index_pw + piecewise_term)
# Plot data with piecewise linear trend
plot(hours, main = "Avg Hrs Worked/Week with Piecewise Linear Trend", ylab = "Avg Hrs Worked", xlab = "Time")
lines(time_index_pw, fitted(fit_piecewise), col = "blue", lwd = 2)
summary(fit_quad)
summary(fit_trend)
summary(fit_piecewise)
data(wages)
# Plot the time series
plot(wages, main="Avg Hourly Wages (1981-1987)", ylab="Wages", xlab="Time")
# Fit a linear time trend model
time_index <- 1:length(wages)
fit_linear <- lm(wages ~ time_index)
# Plot the original time series with the fitted trend line
plot(wages, main="Avg Hourly Wages (1981-1987) with Linear Trend", ylab="Wages", xlab="Time")
abline(fit_linear, col="red", lwd=2)
# Summary of the model
summary(fit_linear)
# Residuals from the linear model
residuals_linear <- residuals(fit_linear)
# Time series plot of residuals
plot(residuals_linear, main="Residuals Over Time", ylab="Residuals", xlab="Time")
# ACF of residuals
acf(residuals_linear, main="ACF of Residuals")
# Histogram of residuals
hist(residuals_linear, main="Histogram of Residuals", xlab="Residuals", breaks=10)
# Ljung-Box test for white noise in residuals
Box.test(residuals_linear, lag=10, type="Ljung-Box")
# Create a time index for the quadratic term
time_index_sq <- time_index^2
# Fit the model using least squares with both time index and its square
fit_quadratic <- lm(wages ~ time_index + I(time_index_sq))
# Display the summary of the fitted model
summary(fit_quadratic)
# Plot the original time series with the fitted quadratic trend
plot(wages, main = "Avg Hourly Wages with Quadratic Trend", ylab = "Wages", xlab = "Time")
lines(fitted(fit_quadratic), col = "red")
time_index <- time(cmort)
# Center the temperature variable
T_centered <- tempr - mean(tempr)
# Fit the linear regression model
fit_model <- lm(cmort ~ time_index + T_centered + I(T_centered^2) + part)
# Display the summary of the model
summary(fit_model)
# Create lagged variable for P_t-4
part_lag4 <- lag(part, -4)
# Adjust variables to match lengths
cmort_adj <- cmort[5:length(cmort)]
tempr_adj <- tempr[5:length(tempr)]
part_adj <- part[5:length(part)]
part_lag4_adj <- part_lag4[5:length(part_lag4)]
# Combine data
data_combined <- data.frame(cmort_adj, tempr_adj, part_adj, part_lag4_adj)
# Scatter plot matrix
pairs(data_combined, main = "Scatter Plot Matrix")
# Pairwise correlations
correlations <- cor(data_combined, use = "complete.obs")
print(correlations)
# Prepare data
time_index <- time(cmort)
T_centered <- tempr - mean(tempr)
# Add Pt-4 (lagged) to the regression
part_lag4 <- lag(part, -4) # Lag the variable
fit_model_lag <- lm(cmort[5:length(cmort)] ~ time_index[5:length(time_index)] +
T_centered[5:length(T_centered)] + I(T_centered[5:length(T_centered)]^2) +
part[5:length(part)] + part_lag4[5:length(part_lag4)])
summary(fit_model_lag)
# Model comparison
cat("R-squared for original model:", summary(fit_model)$r.squared, "\n")
cat("R-squared for model with Pt-4:", summary(fit_model_lag)$r.squared, "\n")
# Install from CRAN
install.packages('rmarkdown')
# Or if you want to test the development version,
# install from GitHub
if (!requireNamespace("devtools"))
install.packages('devtools')
install.packages('tinytex')
tinytex::install_tinytex()  # install TinyTeX
knitr::opts_chunk$set(echo = TRUE)
detach("package:xfun", unload = TRUE)
search()
install.packages("xfun", dependencies = TRUE)
install.packages("xfun", dependencies = TRUE)
knitr::opts_chunk$set(echo = TRUE)
install.packages("xfun", dependencies = TRUE)
tinytex::install_tinytex()
install.packages("xfun", dependencies = TRUE)
tinytex::install_tinytex()
options(defaultPackages = character(0))
remove.packages("xfun")
install.packages("xfun")
install.packages("xfun")
knitr::opts_chunk$set(echo = TRUE)
install.packages("xfun")
install.packages("xfun", dependencies = TRUE)
packageVersion("xfun")
tinytex::install_tinytex()
Y
tinytex::install_tinytex()
y
Y
tinytex::install_tinytex()
Y
tinytex::install_tinytex()
knitr::opts_chunk$set(echo = TRUE)
install.packages("umap")
# Load necessary libraries
library(umap)
library(ggplot2)
# Load the dataset
golub <- read.csv("golub.csv", header = TRUE)
# Extract gene expression data (columns 7 onward)
gene_expr <- golub[, 7:ncol(golub)]
# Run UMAP (default parameters)
set.seed(42)  # for reproducibility
umap_res <- umap(gene_expr)
# Create a data frame with UMAP coordinates and cancer type
umap_df <- data.frame(UMAP1 = umap_res$layout[, 1],
UMAP2 = umap_res$layout[, 2],
Cancer = golub$cancer)
# Plot the UMAP results, coloring by cancer type
ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = Cancer)) +
geom_point(size = 2, alpha = 0.8) +
ggtitle("UMAP Visualization of Golub Data by Cancer Type") +
theme_minimal()
install.packages("umap")
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(umap)
library(ggplot2)
# Load the dataset
golub <- read.csv("golub.csv", header = TRUE)
# Extract gene expression data (columns 7 onward)
gene_expr <- golub[, 7:ncol(golub)]
# Run UMAP (default parameters)
set.seed(42)  # for reproducibility
umap_res <- umap(gene_expr)
# Create a data frame with UMAP coordinates and cancer type
umap_df <- data.frame(UMAP1 = umap_res$layout[, 1],
UMAP2 = umap_res$layout[, 2],
Cancer = golub$cancer)
# Plot the UMAP results, coloring by cancer type
ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = Cancer)) +
geom_point(size = 2, alpha = 0.8) +
ggtitle("UMAP Visualization of Golub Data by Cancer Type") +
theme_minimal()
# Load necessary libraries
library(umap)
library(ggplot2)
# Load the dataset
golub <- read.csv("golub.csv", header = TRUE)
# Extract gene expression data (columns 7 onward)
gene_expr <- golub[, 6:ncol(golub)]
# Run UMAP (default parameters)
set.seed(42)  # for reproducibility
umap_res <- umap(gene_expr)
# Load necessary libraries
library(umap)
library(ggplot2)
# Load the dataset
golub <- read.csv("golub.csv", header = TRUE)
# Extract gene expression data (columns 7 onward)
gene_expr <- golub[, 7:ncol(golub)]
# Run UMAP (default parameters)
set.seed(42)  # for reproducibility
umap_res <- umap(gene_expr)
# Create a data frame with UMAP coordinates and cancer type
umap_df <- data.frame(UMAP1 = umap_res$layout[, 1],
UMAP2 = umap_res$layout[, 2],
Cancer = golub$cancer)
# Plot the UMAP results, coloring by cancer type
ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = Cancer)) +
geom_point(size = 2, alpha = 0.8) +
ggtitle("UMAP Visualization of Golub Data by Cancer Type") +
theme_minimal()
# Scale data (mean 0, variance 1)
scaled_expr <- scale(gene_expr)
# Perform PCA
pca_res <- prcomp(scaled_expr, center = FALSE, scale. = FALSE)  # Already scaled
# Extract the first 5 principal components
X_pca <- pca_res$x[, 1:5]
# Check dimensions (should be 72 rows, 5 columns)
dim(X_pca)
# Scale data (mean 0, variance 1)
scaled_expr <- scale(gene_expr)
# Perform PCA
pca_res <- prcomp(scaled_expr, center = FALSE, scale. = FALSE)  # Already scaled
# Extract the first 5 principal components
X_pca <- pca_res$x[, 1:5]
# Check dimensions (should be 72 rows, 5 columns)
dim(X_pca)
set.seed(42)  # for reproducibility
km <- kmeans(X_pca, centers = 3, nstart = 25)
clusters <- km$cluster
library(umap)
library(ggplot2)
# Run UMAP on the same scaled expression data (or you could use X_pca, but typically
# we do UMAP on the full scaled gene data)
umap_res <- umap(scaled_expr)
# Build a data frame for plotting
umap_df <- data.frame(
UMAP1 = umap_res$layout[, 1],
UMAP2 = umap_res$layout[, 2],
Cluster = factor(clusters)
)
# Plot the UMAP results, coloring by cluster
ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = Cluster)) +
geom_point(size = 2, alpha = 0.8) +
ggtitle("UMAP Visualization Colored by k-Means Clusters") +
theme_minimal()
# Load the data
golub <- read.csv("golub.csv", header = TRUE)
# Create a binary indicator for AML (1 if AML, 0 otherwise)
golub$aml_flag <- as.integer(golub$cancer == "aml")
# Ensure BM.PB is a factor
golub$BM.PB <- factor(golub$BM.PB)
# List of gene columns (assuming columns 7 onward are gene expressions)
genes <- colnames(golub)[7:ncol(golub)]
# Initialize a vector to store p-values for AML effect
pvals <- numeric(length(genes))
names(pvals) <- genes
# Fit a linear model for each gene: gene_expression ~ aml_flag + BM.PB
for (g in genes) {
fit <- lm(as.formula(paste(g, "~ aml_flag + BM.PB")), data = golub)
# Extract the p-value for aml_flag
pvals[g] <- summary(fit)$coefficients["aml_flag", "Pr(>|t|)"]
}
# Load the data
golub <- read.csv("golub.csv", header = TRUE)
# Create a binary indicator for AML (1 if AML, 0 otherwise)
golub$aml_flag <- as.integer(golub$cancer == "aml")
# Ensure BM.PB is a factor
golub$BM.PB <- factor(golub$BM.PB)
# List of gene columns (assuming columns 7 onward are gene expressions)
genes <- colnames(golub)[7:ncol(golub)]
# Initialize a vector to store p-values for AML effect
pvals <- numeric(length(genes))
names(pvals) <- genes
# Fit a linear model for each gene: gene_expression ~ aml_flag + BM.PB
for (g in genes) {
fit <- lm(as.formula(paste(g, "~ aml_flag + BM.PB")), data = golub)
# Extract the p-value for aml_flag
pvals[g] <- summary(fit)$coefficients["aml_flag", "Pr(>|t|)"]
}
# Create the AML indicator and factor for BM.PB
golub$aml_flag <- as.integer(golub$cancer == "aml")
golub$BM.PB <- factor(golub$BM.PB)
# Identify gene columns
genes <- colnames(golub)[7:ncol(golub)]
# Initialize vector for p-values
pvals <- numeric(length(genes))
names(pvals) <- genes
# For each gene, create a small data frame and fit the linear model
for (g in genes) {
# Outcome
y <- golub[[g]]
# Put outcome + predictors in one data frame
model_df <- data.frame(
y = y,
aml_flag = golub$aml_flag,
BM.PB = golub$BM.PB
)
# Fit the linear model: y ~ aml_flag + BM.PB
fit <- lm(y ~ aml_flag + BM.PB, data = model_df)
# Extract p-value for aml_flag
pvals[g] <- summary(fit)$coefficients["aml_flag", "Pr(>|t|)"]
}
# Adjust p-values using the Benjamini-Hochberg FDR method
adj_pvals <- p.adjust(pvals, method = "fdr")
# Mark genes as DE if FDR ≤ 0.05
de_genes <- names(adj_pvals)[adj_pvals <= 0.05]
# Create AML indicator and factor for BM/PB
golub$aml_flag <- as.integer(golub$cancer == "aml")
golub$BM.PB <- factor(golub$BM.PB)
# Identify gene columns (columns 7 onward)
genes <- colnames(golub)[7:ncol(golub)]
# Initialize a vector to store p-values
pvals <- numeric(length(genes))
names(pvals) <- genes
# Loop through each gene
for (g in genes) {
# Extract gene expression
y <- golub[[g]]
# Skip if zero variance
if (sd(y) == 0) {
pvals[g] <- NA
next
}
# Build a small data frame for the model
model_df <- data.frame(
y = y,
aml_flag = golub$aml_flag,
BM.PB = golub$BM.PB
)
# Safely fit the linear model (catch errors)
fit <- tryCatch(
lm(y ~ aml_flag + BM.PB, data = model_df),
error = function(e) NULL
)
# If the model was successfully fit
if (!is.null(fit)) {
coefs <- summary(fit)$coefficients
# Ensure "aml_flag" row exists in the coefficients table
if ("aml_flag" %in% rownames(coefs)) {
pvals[g] <- coefs["aml_flag", "Pr(>|t|)"]
} else {
pvals[g] <- NA
}
} else {
pvals[g] <- NA
}
}
# 1) We've identified p-values for AML effect while adjusting for BM vs. PB.
# 2) FDR adjustment
adj_pvals <- p.adjust(pvals, method = "fdr")
# Mark genes as DE if FDR <= 0.05
de_genes <- names(adj_pvals)[adj_pvals <= 0.05]
# 3) Number of differentially expressed genes
num_de_genes <- length(de_genes)
cat("Number of differentially expressed genes (FDR ≤ 0.05):", num_de_genes, "\n")
# 4) Gene with the smallest (raw) p-value
most_de_gene <- names(which.min(pvals))
cat("Most differentially expressed gene by p-value:", most_de_gene, "\n")
knitr::opts_chunk$set(echo = TRUE)
library(edgeR)
library(tidyverse)
library(edgeR)
library(dplyr)       # for data manipulation
library(tidyr)       # for pivot_*
library(readr)
message("Running R version: ", R.version.string)
if (!requireNamespace("BiocManager", quietly=TRUE)) install.packages("BiocManager")
BiocManager::install(c("edgeR","limma"), ask=FALSE, update=FALSE)
message("Running R version: ", R.version.string)
# 2️⃣ Force‑rebuild Bioconductor packages under your current R
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install(
c("edgeR", "limma"),
ask     = FALSE,
update  = FALSE,
force   = TRUE    # <—— rebuild even if “up‑to‑date”
)
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)      # For Read10X_h5()
library(edgeR)       # For differential expression
library(dplyr)       # For simple data handling
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
library(clusterProfiler)
library(org.Mm.eg.db)  # For mouse. For human, use org.Hs.eg.db, etc.
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("org.Mm.eg.db")
library(clusterProfiler)
library(org.Mm.eg.db)  # For mouse. For human, use org.Hs.eg.db, etc.
# Extract just the vector of gene symbols from your up/down data
up_gene_symbols   <- up_genes$Gene
reticulate::repl_python()
reticulate::repl_python()
